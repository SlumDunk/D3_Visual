<!DOCTYPE html>
<meta charset="utf-8">
<style>

    body {
        font: 10px sans-serif;
    }

    .axis path,
    .axis line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
    }

    .dot {
        stroke: #000;
    }

    .lasso path {
        stroke: rgb(80, 80, 80);
        stroke-width: 2px;
    }

    .lasso .drawn {
        fill-opacity: .05;
    }

    .lasso .loop_close {
        fill: none;
        stroke-dasharray: 4, 4;
    }

    .lasso .origin {
        fill: #3399FF;
        fill-opacity: .5;
    }

    .not_possible {
        fill: rgb(200, 200, 200);
    }

    .possible {
        fill: #EC888C;
    }

    .container {
        position: relative;
        width: 1800px;
        height: 600px;
    }
</style>
<body>
<div class="container">
    <div id="left-div" style="width:33.3%;height:100%;float:left;"></div>
    <div id='right-div' style="width:33.3%;height:100%;float:left;"></div>
    <div id="bottom-div" style="width:33.3%;height:100%;float:left;">
        <input type="button" id='reset' style="opacity: 0;" value="reset">
    </div>
</div>
<script src="./js/axios.min.js"></script>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://axc.net/code_libraries/lasso/lasso.min.js"></script>
<script>

    let margin = {top: 20, right: 20, bottom: 30, left: 40},
        width = 960 - margin.left - margin.right,
        height = 500 - margin.top - margin.bottom;

    axios.get('http://127.0.0.1:8000/wiki/data', {
        params: {
            time_start: 5,
            time_end: 5,
            good_start: 5,
            good_end: 5,
            bad_start: 5,
            bad_end: 5
        }
    }).then(function (response) {
        let data=response.data
        data.forEach(function (d) {
            d.sepalLength = +d.x;
            d.sepalWidth = +d.y;
        });

        let x = d3.scale.linear()
            .range([0, width]);

        let y = d3.scale.linear()
            .range([height, 0]);

        let color = d3.scale.category10();

        let xAxis = d3.svg.axis()
            .scale(x)
            .orient("bottom");

        let yAxis = d3.svg.axis()
            .scale(y)
            .orient("left");

        x.domain(d3.extent(data, function (d) {
            return d.sepalWidth;
        })).nice();
        y.domain(d3.extent(data, function (d) {
            return d.sepalLength;
        })).nice();

        let svg = d3.select("#bottom-div").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // Lasso functions to execute while lassoing
        let lasso_start = function () {
            lasso.items()
                .attr("r", 3.5) // reset size
                .style("fill", null) // clear all of the fills
                .classed({"not_possible": true, "selected": false}); // style as not possible
        };

        let lasso_draw = function () {
            // Style the possible dots
            lasso.items().filter(function (d) {
                return d.possible === true
            })
                .classed({"not_possible": false, "possible": true});

            // Style the not possible dot
            lasso.items().filter(function (d) {
                return d.possible === false
            })
                .classed({"not_possible": true, "possible": false});
        };

        let lasso_end = function () {
            // Reset the color of all dots
            lasso.items()
                .style("fill", function (d) {
                    return color(d.species);
                });

            // Style the selected dots
            lasso.items().filter(function (d) {
                return d.selected === true
            })
                .classed({"not_possible": false, "possible": false})
                .attr("r", 7);

            // Reset the style of the not selected dots
            lasso.items().filter(function (d) {
                return d.selected === false
            })
                .classed({"not_possible": false, "possible": false})
                .attr("r", 3.5);

        };

        // Create the area where the lasso event can be triggered
        let lasso_area = svg.append("rect")
            .attr("width", width)
            .attr("height", height)
            .style("opacity", 0);

        // Define the lasso
        let lasso = d3.lasso()
            .closePathDistance(75) // max distance for the lasso loop to be closed
            .closePathSelect(true) // can items be selected by closing the path?
            .hoverSelect(true) // can items by selected by hovering over them?
            .area(lasso_area) // area where the lasso can be started
            .on("start", lasso_start) // lasso start function
            .on("draw", lasso_draw) // lasso draw function
            .on("end", lasso_end); // lasso end function

        // Init the lasso on the svg:g that contains the dots
        svg.call(lasso);


        svg.append("g")
            .classed("x axis", true)
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis)
            .append("text")
            .classed("label", true)
            .attr("x", width)
            .attr("y", margin.bottom - 10)
            .style("text-anchor", "end")
            .text('xCat');

        svg.append("g")
            .classed("y axis", true)
            .call(yAxis)
            .append("text")
            .classed("label", true)
            .attr("transform", "rotate(-90)")
            .attr("y", -margin.left)
            .attr("dy", ".71em")
            .style("text-anchor", "end")
            .text('yCat');

        let objects = svg.append("svg")
            .classed("objects", true)
            .attr("width", width)
            .attr("height", height);

        objects.append("svg:line")
            .classed("axisLine hAxisLine", true)
            .attr("x1", 0)
            .attr("y1", 0)
            .attr("x2", width)
            .attr("y2", 0)
            .attr("transform", "translate(0," + height + ")");

        objects.append("svg:line")
            .classed("axisLine vAxisLine", true)
            .attr("x1", 0)
            .attr("y1", 0)
            .attr("x2", 0)
            .attr("y2", height);


        objects.selectAll(".dot")
            .data(data)
            .enter().append("circle")
            .attr("id", function (d, i) {
                return "dot_" + i;
            }) // added
            .attr("class", "dot")
            .attr("r", 3.5)
            .attr("cx", function (d) {
                return x(d.sepalWidth);
            })
            .attr("cy", function (d) {
                return y(d.sepalLength);
            })
            .style("fill", function (d) {
                return 'green';
            });

        lasso.items(d3.selectAll(".dot"));

        let legend = svg.selectAll(".legend")
            .data(color.domain())
            .enter().append("g")
            .attr("class", "legend")
            .attr("transform", function (d, i) {
                return "translate(0," + i * 20 + ")";
            });

        legend.append("rect")
            .attr("x", width - 18)
            .attr("width", 18)
            .attr("height", 18)
            .style("fill", color);

        legend.append("text")
            .attr("x", width - 24)
            .attr("y", 9)
            .attr("dy", ".35em")
            .style("text-anchor", "end")
            .text(function (d) {
                return d;
            });

    });

    d3.tsv("./data/data.tsv", function (error, data) {

    });

</script>